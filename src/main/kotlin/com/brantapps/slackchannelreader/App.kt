/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.brantapps.slackchannelreader

import com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory
import io.reactivex.schedulers.Schedulers
import kotlinx.serialization.json.Json
import okhttp3.MediaType
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import org.apache.commons.csv.CSVFormat
import org.apache.commons.csv.CSVPrinter
import retrofit2.Retrofit
import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory
import java.nio.file.Files
import java.nio.file.Paths

class ChannelReader {

    @kotlinx.serialization.UnstableDefault
    companion object {
        private val contentType = MediaType.get("application/json")
        val retrofit: Retrofit = Retrofit.Builder()
                .baseUrl("https://slack.com/api/")
                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                .addConverterFactory(Json.nonstrict.asConverterFactory(contentType))
                .client(buildOkHttpClient())
                .build()

        fun buildOkHttpClient(): OkHttpClient {
            val logging = HttpLoggingInterceptor()
            logging.level = HttpLoggingInterceptor.Level.BODY
            val httpClient = OkHttpClient.Builder()
            //httpClient.addInterceptor(logging)
            return httpClient.build()
        }
    }
}

fun main(args: Array<String>) {
    val writer = Files.newBufferedWriter(Paths.get("active-slack-channels.csv"))
        val csvPrinter = CSVPrinter(writer, CSVFormat.DEFAULT
            .withHeader(
                    "Channel Name",
                    "Description",
                    "Creator",
                    "Team ID",
                    "Creator Handle",
                    "Created Date",
                    "# of members",
                    "# of messages"
            )
    )
    ChannelService()
            .getChannelOverviews(args[0], args[1].toLong())
            .map {
                csvPrinter.printRecord(
                        it.name,
                        it.purpose,
                        it.creator.realName,
                        it.creator.team,
                        it.creator.displayName,
                        it.created,
                        it.numberOfMembers,
                        it.messagesSentInPeriod
                )
            }
            .observeOn(Schedulers.single())
            .blockingSubscribe()

    csvPrinter.flush()
    csvPrinter.close()

    val channelAttendenceWriter = Files.newBufferedWriter(Paths.get("channel-attendence.csv"))
    val channelAttendencePrinter = CSVPrinter(channelAttendenceWriter, CSVFormat.DEFAULT
            .withHeader(
                    "User",
                    "# of Channels",
                    "Channels"
            )
    )

    val map = mutableMapOf<User, MutableList<String>>()
    ChannelService()
            .getChannelAttendance(args[0])
            .map {
                it.forEach { each ->
                    val values = map.get(each.key.user)
                    values?.add(each.value)
                    if (values != null) {
                        map.put(each.key.user, values)
                    } else {
                        map.put(each.key.user, arrayListOf(each.value))
                    }
                }
            }
            .observeOn(Schedulers.single())
            .blockingSubscribe()

    map.map {
        channelAttendencePrinter.printRecord(
                it.key.profile.real_name,
                it.value.size,
                it.value
        )
    }

    channelAttendencePrinter.flush()
    channelAttendencePrinter.close()
}
